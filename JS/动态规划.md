## 动态规划

作为前端，平时接触到算法会比较少，但是这并不代表着算法不重要，据不完全统计，百分之 90 的大佬说：决定一个程序员能走多远算法能力是及其非常重要的。况且现在越来越多的公司，尤其是大公司在考察候选者的时候，也开始更多得加入算法题目。所以无论是从长远的职业发展还是短期的跳槽找工作，学习算法都是非常必要的。

而在所有算法中，动态规划法是最常用的。甚至可以说，熟练掌握动态规划法，基本能解决百分之 70 的算法题了。

- 从一道面试题开始

假设现在有足够数量的 1 元，4 元，5 元的硬币，目标是凑出 n 元钞票所需要的硬币最小数量是多少。

按照我们一般的想法是，能用 5 元就用 5 元，然后再用 4 元，之后实在没有办法了选择使用 1 元的硬币。这种“贪心策略”在有时候是正确的，比如我们凑个 10 元的时候，会选择 2 枚 5 元的硬币，但是如果我们需要凑 8 元的时候，”贪心策略会“出错，因为根据这个策略，我们会选择 1 枚 5 元和 3 枚 1 元的硬币，总计硬币数为 4 枚，而更优的策略明显是选择 2 枚 4 元硬币。所以这里需要用到我们的动态规划法。

我们用 f(n)来表示“凑出 n 元面值所需的最少硬币数量”。假设我们取了 1 枚 5 元的硬币，那么我们接下来我们需要面对 n = 3 的情况，所以我们可以写出如下表达式：
cost = f(3) + 1 = 3 + 1 = 4 。它的意义在于，如果我们选择了 1 枚 5 元的硬币，付出的代价 是 f(3)再加上自己这一枚硬币，暂时不管 f(3)要怎么计算出来。
同理我们可以得到：

cost = f(4) + 1 = 1 + 1 = 2;
cost = f(7) + 1 = 3 + 1 = 4;

由表达式可以知道，其实 f(n)只和 f(n-1),f(n-4),f(n-5)相关，我们甚至可以写出它们的表达式：

f(n) = min{f(n-1), f(n-4), f(n-5)} + 1;

我们将其转化为代码，如下

```js
function minCoin(n) {
  const f = [];
  f[0] = 0;
  for (let i = 1; i <= n; i++) {
    let cost = Math.pow(2, 53);
    if (i - 1 >= 0) cost = Math.min(cost, f[i - 1] + 1);
    if (i - 4 >= 0) cost = Math.min(cost, f[i - 4] + 1);
    if (i - 5 >= 0) cost = Math.min(cost, f[i - 5] + 1);
    f[i] = cost;
  }
  return f[n];
}
```

回顾我们的实现方式，其实我们只在乎两点：

（1）f(n)只与 f(n-1),f(n-4),f(n-5)有关

（2）在这个过程中，其实我们只关心 f(n),至于如何凑出 n,我们并不关心

换一句话说，当我们想要求出 f(8)的时候，只需要知道 f(3),f(4),f(7)的值，其他的信息根本不重要。这就是动态规划

将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。

- 两个概念

一、无后效性

根据定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

就像我们我们上面所说，我们只关心 f(n)，到底怎么凑出 n 的不再我们的考虑范围之内。我们求 f(8)的值，只需要知道 f(3),f(4),f(7)的值。至于这些值如果求出，对之后的问题木有影响。

二、最优子结构

如果一个大问题的最优解，可以由小问题的最优解推出，即满足“最优子结构性质”。

假设从杭州去往温州，必须经过台州。那么如果需要求出杭州去温州的最短距离，可以分别求出杭州到台州的最短距离与台州到温州的最短距离，然后再相加。

凡是满足这两个条件的问题，都可以通过动态规划法去解决。

- 如何使用动态规划法

**核心思想**：“问题拆解”。将大问题拆分成小问题，计算出小问题的解，反推大问题的解。

如何设计一个动态规划算法一般要明确以下几个问题：

1. 状态是什么

2. 状态转移方程是什么

3. 状态的初始值是什么

4. 问题要求的最后答案是什么

以上步骤分析完成，就基本上解决了整道动态规划的问题

- 例题：最长递增子序列

多说无益，通过一道例题来加深以下印象。

最长递增子序列问题的意思是在一组数字中，找出最长一串递增的数字，比如

0, 3, 4, 17, 2, 8, 6, 10

对于以上这串数字来说，最长递增子序列就是 0, 3, 4, 8, 10。

按照上述所说，第一步需要我们设计好状态，我们记${x_2}$ .

```js
function lis(n) {
  if (n.length === 0) return 0;
  let arr = new Array(n.length).fill(1);
  for (let i = 1; i < n.length; i++) {
    for (let j = 0; j < i; j++) {
      if (n[i] > n[j]) {
        arr[i] = Math.max(arr[i], arr[j] + 1);
      }
    }
  }
  let res = 1;
  for (let i = 1; i < array.length; i++) {
    res = Math.max(res, array[i]);
  }
  return res;
}
```

通过上述两个例题可以看出，动态规划的思想在于，把大问题拆解成小问题，带着这个思想，动态规划法能成为我们解决问题的利器。
