## 动态规划

作为前端，平时接触到算法会比较少，但是这并不代表着算法不重要，据不完全统计，百分之 90 的大佬说：决定一个程序员能走多远算法能力是及其非常重要的。况且现在越来越多的公司，尤其是大公司在考察候选者的时候，也开始更多得加入算法题目。所以无论是从长远的职业发展还是短期的跳槽找工作，学习算法都是非常必要的。

而在所有算法中，动态规划法是最常用的。甚至可以说，熟练掌握动态规划法，基本能解决百分之 70 的算法题了。

- 从一道面试题开始

假设现在有足够数量的 1 元，4 元，5 元的硬币，目标是凑出 n 元钞票所需要的硬币最小数量是多少。

按照我们一般的想法是，能用 5 元就用 5 元，然后再用 4 元，之后实在没有办法了选择使用 1 元的硬币。这种“贪心策略”在有时候是正确的，比如我们凑个 10 元的时候，会选择 2 枚 5 元的硬币，但是如果我们需要凑 8 元的时候，”贪心策略会“出错，因为根据这个策略，我们会选择 1 枚 5 元和 3 枚 1 元的硬币，总计硬币数为 4 枚，而更优的策略明显是选择 2 枚 4 元硬币。所以这里需要用到我们的动态规划法。

我们用 f(n)来表示“凑出 n 元面值所需的最少硬币数量”。假设我们取了 1 枚 5 元的硬币，那么我们接下来我们需要面对 n = 3 的情况，所以我们可以写出如下表达式：
cost = f(3) + 1 = 3 + 1 = 4 。它的意义在于，如果我们选择了 1 枚 5 元的硬币，付出的代价 是 f(3)再加上自己这一枚硬币，暂时不管 f(3)要怎么计算出来。
同理我们可以得到：

cost = f(4) + 1 = 1 + 1 = 2;
cost = f(7) + 1 = 3 + 1 = 4;

由表达式可以知道，其实 f(n)只和 f(n-1),f(n-4),f(n-5)相关，我们甚至可以写出它们的表达式：

f(n) = min{f(n-1), f(n-4), f(n-5)} + 1;

我们将其转化为代码，如下

```js
function minCoin(n) {
  const f = [];
  f[0] = 0;
  for (let i = 1; i <= n; i++) {
    let cost = Math.pow(2, 53);
    if (i - 1 >= 0) cost = Math.min(cost, f[i - 1] + 1);
    if (i - 4 >= 0) cost = Math.min(cost, f[i - 4] + 1);
    if (i - 5 >= 0) cost = Math.min(cost, f[i - 5] + 1);
    f[i] = cost;
  }
  return f[n];
}
```
